%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dual Trace Communication Event Analysis
% 
% Author: Nora Huang
% Date: July 2017
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[paper=a4, fontsize=11pt]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage{fourier}
\usepackage{tabu}
\usepackage{float}
\usepackage{afterpage}
\usepackage{booktabs}

\usepackage{longtable}
\usepackage{multicol}
\usepackage{multirow}

\usepackage[english]{babel}															% English language/hyphenation
\usepackage[protrusion=true,expansion=true]{microtype}	
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage[pdftex]{graphicx}	
\usepackage{url}
\usepackage{listings}
\lstset{
    frame=single,
    breaklines=true
}


%%% Custom sectioning
\usepackage{sectsty}
\allsectionsfont{\centering \normalfont\scshape}


%%% Custom headers/footers (fancyhdr package)
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\fancyhead{}											% No page header
\fancyfoot[L]{}											% Empty 
\fancyfoot[C]{}											% Empty
\fancyfoot[R]{\thepage}									% Pagenumbering
\renewcommand{\headrulewidth}{0pt}			% Remove header underlines
\renewcommand{\footrulewidth}{0pt}				% Remove footer underlines
\setlength{\headheight}{13.6pt}


%%% Equation and float numbering
\numberwithin{equation}{section}		% Equationnumbering: section.eq#
\numberwithin{figure}{section}			% Figurenumbering: section.fig#
\numberwithin{table}{section}				% Tablenumbering: section.tab#


%%% Maketitle metadata
\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} 	% Horizontal rule

\title{
		%\vspace{-1in} 	
		\usefont{OT1}{bch}{b}{n}
		\normalfont \normalsize \textsc{Department of Computer Science,  University of Victoria} \\ [25pt]
		\horrule{0.5pt} \\[0.4cm]
		\huge Dual Trace Communication Event Analysis  \\
		\horrule{2pt} \\[0.5cm]
}
\author{
		\normalfont 								\normalsize
        Nora Huang\\[-3pt]		\normalsize
        \today
}
\date{}


%%% Begin document
\begin{document}
\maketitle

\section{Introduction}
Many network application vulnerabilities occur not just in one application, but in how they interact with other systems. These kinds of vulnerabilities can be difficult to analyze. Dual-trace analysis is one approach that helps the security engineers to detect the vulnerabilities in the interactive software. A dual-trace consist of two execution traces that are generated from two interacting applications. Each of these traces contains information including CPU instructions, register and memory changes of the running application. Communication information of the interacting applications is captured as the register or memory changes on their respective sides. Our research focuses on building a model to visualize and analyze dual-trace which would be available for various kinds of communication methods such as UDP, TCP and named pipe. 

\subsection{Problem}
The major problem in dual-trace analysis is synchronization of the traces from both sides. We narrow down the problem into finding the sending points and receiving points of the communication messages and pair them. 

\subsection{solution}

\section{Prototype Building}
In this section we discuss the design of the prototype on how we match the send and receive events in the sender side trace and the receiver side trace. This prototype consist of three main components: defining the communication type, locating the communication events by matching the send and receive events on sender and receiver sides, navigating the located events in the sender and receiver traces. We provide the background information of the design of each component as well as its detail design in each corresponding subsection.
\subsection{User Defined Communication Type}
In our design, we don't specify any predefined communication type but give the user capacity to do that. By the user interface implemented in our tool, the user can defined their own communication type. This give the flexibility to the user to define what they are looking for. Each communication type consist of 4 system function calls. They are sender and receiver channel create/open, sender's send message function and receiver's receive message function. By indicating these the channel create/open function in both sender and receiver sides, the tool can acquire the channel's identifiers when they are created or opened. Later on the tool can match the send and received messages within a specific channel. The send and receive are used to located the event happened in the traces. The messages send and received are reconstructed from the memory state when the send and receive functions are called and returned. This detail of the match algorithm will be discuss later.
\subsubsection{Assembly Calling Convention}
To defined the communication type, users have to know the basic calling convention of the system call. 
Calling Convention is different for operating system and the programming language. Our prototype only be tested on traces of Microsoft 64 with C/C++ program. It seems too specific, however, the prototype can be adapted easily to other conventions. As long as users know the calling convention of their operating system, they can define their communication type with our tool. We list the related Microsoft 64 with C/C++ program convention here for reference and example. For more detail about the calling convention, users should refer to the operating system specification.\par
For the Microsoft* x64 calling convention, the additional register space let fastcall be the only calling convention (under x86 there were many: stdcall, thiscall, fastcall, cdecl, etc.). The rules for interfacing with C/C++ style functions:\par
\begin{enumerate}  
\item RCX, RDX, R8, R9 are used for integer and pointer arguments in that order left to right.
\item XMM0, 1, 2, and 3 are used for floating point arguments.
\item Additional arguments are pushed on the stack left to right. \ldots 
\item Parameters less than 64 bits long are not zero extended; the high bits contain garbage.
\item Integer return values (similar to x86) are returned in RAX if 64 bits or less.
\item Floating point return values are returned in XMM0.
\item Larger return values (structs) have space allocated on the stack by the caller, and RCX then contains a pointer to the return space when the callee is called. Register usage for integer parameters is then pushed one to the right. RAX returns this address to the caller.
\end{enumerate}


\subsubsection{Function Calls in the Traces}
The called functions' name can be inspected  by  search of the symbolic name in the executable binary or any DLLs which used by the program at the time when it is traced. This functionality exists in the current Atlantis. By importing the Dlls and execution  executable binary, Atlantis can list all called functions for the users in the Functions view. From this list, users can chose the interested functions and generate their interested communication type. In Figure 1 there is  an action item call "Add to Communication type" in the right click menu of the function entry. Figure 2 shows the dialogue for entering the information for the added function. The needed information is the communication type's name. User can get the existing communication type list in the drop down menu. They can choose to add the current function to an exist communication type or they can add it to a new communication type by entering a new name. For the channel create/open function, the register holding the address of channel's name as input and the register holding the handle identification of the channel as output are required. For the send/receive function, the register holding the address of the send/receiver buffer, the register holding the length of the sending/receiving message and the register holding the channel's identification are required. As there are 4 functions for each communication type the user has to repeat this add function to communication type action for 4 time to generate one communication type.

\subsubsection{Communication Type Data Structure}
The defined communication type will be stored in a xml file. The list below shows the data structure of one communication type. 
\begin{lstlisting}
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<messageTypesData>
    <parentFolder>.tmp</parentFolder>
    <messageTypes>
        <messageType>
            <name>clientsend</name>
            <send>
                <functionType>Send</functionType>
                <associatedFileName>Client</associatedFileName>
                <name>WriteFile</name>
                <messageAddress>RDX</messageAddress>
                <messageLengthAddress>R8</messageLengthAddress>
                <channelIdReg>RCX</channelIdReg>
                <first>
                    <instructionNameIndex>4</instructionNameIndex>
                    <moduleName>kernel32.dll</moduleName>
                    <moduleId>1998979072</moduleId>
                    <fullText></fullText>
                    <moduleOffset>139056</moduleOffset>
                    <firstLine>0</firstLine>
                    <uniqueIdentifier>1998979072:1999118128</uniqueIdentifier>
                    <parentFunction>1998979072:1999116080</parentFunction>
                </first>
            </send>
            <receive>
                <functionType>Receive</functionType>
                <associatedFileName>Server</associatedFileName>
                <name>ReadFile</name>
                <messageAddress>RDX</messageAddress>
                <messageLengthAddress>R8</messageLengthAddress>
                <channelIdReg>RCX</channelIdReg>
                <first>
                    <instructionNameIndex>1</instructionNameIndex>
                    <moduleName>kernel32.dll</moduleName>
                    <moduleId>1998979072</moduleId>
                    <fullText></fullText>
                    <moduleOffset>68000</moduleOffset>
                    <firstLine>0</firstLine>
                    <uniqueIdentifier>1998979072:1999047072</uniqueIdentifier>
                    <parentFunction>-124387328:8791673856012</parentFunction>
                </first>
            </receive>
            <sendChannelCreate>
                <functionType>SendChannelCreate</functionType>
                <associatedFileName>Client</associatedFileName>
                <name>CreateFileA</name>
                <messageAddress>-</messageAddress>
                <messageLengthAddress>-</messageLengthAddress>
                <channelIdReg>RAX</channelIdReg>
                <channelNameAddress>RCX</channelNameAddress>
                <first>
                    <instructionNameIndex>1</instructionNameIndex>
                    <moduleName>kernel32.dll</moduleName>
                    <moduleId>1998979072</moduleId>
                    <fullText></fullText>
                    <moduleOffset>138112</moduleOffset>
                    <firstLine>0</firstLine>
                    <uniqueIdentifier>1998979072:1999117184</uniqueIdentifier>
                    <parentFunction>1062535168:5357506560</parentFunction>
                </first>
            </sendChannelCreate>
            <receiveChannelCreate>
                <functionType>ReceiveChannelCreate</functionType>
                <associatedFileName>Server</associatedFileName>
                <name>CreateNamedPipeA</name>
                <messageAddress>-</messageAddress>
                <messageLengthAddress>-</messageLengthAddress>
                <channelIdReg>RAX</channelIdReg>
                <channelNameAddress>RCX</channelNameAddress>
                <first>
                    <instructionNameIndex>2</instructionNameIndex>
                    <moduleName>kernel32.dll</moduleName>
                    <moduleId>1998979072</moduleId>
                    <fullText></fullText>
                    <moduleOffset>404960</moduleOffset>
                    <firstLine>0</firstLine>
                    <uniqueIdentifier>1998979072:1999384032</uniqueIdentifier>
                    <parentFunction>-124387328:8791673856012</parentFunction>
                </first>
            </receiveChannelCreate>
        </messageType>
    </messageTypes>
</messageTypesData>
\end{lstlisting}


\subsubsection{Communication Type View}
A new view named MessageType view is added for the user defined communication types. All user defined communication type are listed in this view. User can change the name of a communication type, remove an existing communication type or searching of the match message occurrences of selected communication type by selecting the selected action item in the right click menu of an communication type entry. The matched messages are listed in the sub window of the view. By clicking the entry of the search  result, user can navigate to it's sender or receiver's corresponding instruction line. Message content in the memory view will be shown as well.

\subsection{Communication Event Matching}
The communication Event is 
\subsubsection{Matching Channel}
\subsubsection{Matching Message}
\subsubsection{Event Status: Success or Fail}
\subsubsection{Match Events Ordering}
\subsubsection{Matching Event Data Structure}
\begin{table}[h]
 \begin{center}
  \caption{Matched message pair data structure}
\label{table2}
\begin{tabular}{|c|c|c|c|c|}
      \hline
         Message& sender function name & sender line number  & receiver function name & receiver line number \\
       \hline
\end{tabular}
\end{center}
\end{table}
\subsection{Matching Event Visualization and Navigation}
\subsubsection{Navigating to The Sender/Receiver}
\subsubsection{Message Shown in memory view}



\section{Case Analysis}
\subsection{Blocking I/O Namedpipe}
\subsubsection{communication type definition}
\begin{table}
        \centering
        \caption{Information of communication methods in Windows}
        \label{communicatemethod}
        \begin{tabular}{|l|l|l|l|l|l|l|}
            \hline
             \multirow{2}{*}{Method} &
               \multicolumn{3}{c|}{Sender} &
               \multicolumn{3}{c|}{Receiver} \\
             \cline{2-7}
             &  DLL & Function& Parameters & DLL  & Function & Parameters\\
             \hline
             Namedpipe& Kernel32.dll& Writefile&  RCX: File handler & Kernel32.dll & ReadFile &  RCX: File handler\\
             \cline{4-4} \cline{7-7}
             &&&RDX: Buffer Address&&&RDX: Buffer Address\\
              \cline{4-4} \cline{7-7}
               &&&R8:message length&&&R8:message length\\
               \hline
             Winsock & Ws2$\_$32.dll & send & RCX: socket & Ws2$\_$32.dll & recv & RCX: socke \\
              \cline{4-4} \cline{7-7}
             &&&RDX: Buffer Address&&&RDX:Buffer Address\\
              \cline{4-4} \cline{7-7}
               &&&R8: message length&&&R8: message length\\
            \hline
        \end{tabular}
    \end{table}
\subsubsection{Experiment Design}
\subsubsection{Result}
\subsubsection{Time Analysis}
\subsubsection{Limitation}

\section{Future Work}


\bibliographystyle{abbrv}
\bibliography{referencelist} 


%%% End document
\end{document}