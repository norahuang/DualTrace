package ca.uvic.chisel.atlantis;

import static ca.uvic.chisel.atlantis.preferences.SyntaxHighlightingPreference.*;

import ca.uvic.chisel.atlantis.preferences.SecurePreferenceStore;
import ca.uvic.chisel.atlantis.tracedisplayer.TracePartitionScanner;
import ca.uvic.chisel.bfv.BigFileActivator;

import org.eclipse.equinox.security.storage.ISecurePreferences;
import org.eclipse.equinox.security.storage.SecurePreferencesFactory;
import org.eclipse.jface.preference.*;
import org.eclipse.jface.resource.*;
import org.eclipse.swt.SWT;
import org.eclipse.swt.SWTError;
import org.eclipse.swt.graphics.RGB;
import org.eclipse.swt.widgets.Display;
import org.eclipse.ui.PlatformUI;
import org.osgi.framework.*;

/**
 * The activator class controls the plug-in life cycle
 * @author Laura Chan (some code auto-generated by Eclipse)
 */
public class AtlantisActivator extends BigFileActivator {

	// The plug-in ID
	public static final String PLUGIN_ID = "ca.uvic.chisel.atlantis"; //$NON-NLS-1$

	// The shared instance
	private static AtlantisActivator plugin;

	private SecurePreferenceStore securePreferenceStore;

	private TracePartitionScanner tracePartitionScanner;

	@Override
	public void start(BundleContext context) throws Exception {
		super.start(context);
		plugin = this;
	}
	
	/**
	 * Returns the shared instance
	 *
	 * @return the shared instance
	 */
	public static AtlantisActivator getDefault() {
		return plugin;
	}

	/**
	 * Sets up a ColorRegistry for managing colours used by this application. 
	 * @param registry ColorRegistry to initialize
	 */
	public void initializeColorRegistry(ColorRegistry registry) {
		
		super.initializeColorRegistry(registry);
		
		// Add syntax highlighting colours from preferences
		IPreferenceStore preferences = this.getPreferenceStore();
		registry.put(AtlantisColourConstants.SYNTAX_SYSTEM_EVENT, PreferenceConverter.getColor(preferences, SYSTEM_EVENT_COLOUR.getName()));
		registry.put(AtlantisColourConstants.SYNTAX_THREAD, PreferenceConverter.getColor(preferences, THREAD_COLOUR.getName()));
		registry.put(AtlantisColourConstants.SYNTAX_MODULE_LOAD_UNLOAD, PreferenceConverter.getColor(preferences, 
				MODULE_LOAD_UNLOAD_COLOUR.getName()));
		registry.put(AtlantisColourConstants.SYNTAX_OPERATION, PreferenceConverter.getColor(preferences, OPERATION_COLOUR.getName()));
		registry.put(AtlantisColourConstants.SYNTAX_REGISTER, PreferenceConverter.getColor(preferences, REGISTER_COLOUR.getName()));
		registry.put(AtlantisColourConstants.SYNTAX_KEYWORD, PreferenceConverter.getColor(preferences, KEYWORD_COLOUR.getName()));
		registry.put(AtlantisColourConstants.SYNTAX_PROBLEM, PreferenceConverter.getColor(preferences, PROBLEM_COLOUR.getName()));
		registry.put(AtlantisColourConstants.SYNTAX_NOT_EXECUTED, PreferenceConverter.getColor(preferences, NOT_EXECUTED_COLOUR.getName()));

		// Add trace visualization thread colours 
		registry.put(AtlantisColourConstants.THREAD_ROW, new RGB(238, 238, 238));
		// TODO adjust these colours later--they're not particularly pretty, and may not be colour blind friendly
		registry.put(AtlantisColourConstants.THREAD_BEGIN_DEFAULT, new RGB(0, 128, 0));
		registry.put(AtlantisColourConstants.THREAD_BEGIN_SELECTED, new RGB(0, 255, 0));
		registry.put(AtlantisColourConstants.THREAD_END_DEFAULT, new RGB(128, 0, 0));
		registry.put(AtlantisColourConstants.THREAD_END_SELECTED, new RGB(255, 0, 0));
		registry.put(AtlantisColourConstants.THREAD_SWITCH_DEFAULT, new RGB(0, 0, 128));
		registry.put(AtlantisColourConstants.THREAD_SWITCH_SELECTED, new RGB(0, 255, 255));

		// Add trace visualization thread colours 
		registry.put(AtlantisColourConstants.ASSEMBLY_ROW, new RGB(238, 238, 238));
		// TODO adjust these colours later--they're not particularly pretty, and may not be colour blind friendly
		registry.put(AtlantisColourConstants.ASSEMBLY_BEGIN_DEFAULT, new RGB(0, 128, 0));
		registry.put(AtlantisColourConstants.ASSEMBLY_BEGIN_SELECTED, new RGB(0, 255, 0));
		registry.put(AtlantisColourConstants.ASSEMBLY_END_DEFAULT, new RGB(128, 0, 0));
		registry.put(AtlantisColourConstants.ASSEMBLY_END_SELECTED, new RGB(255, 0, 0));
		registry.put(AtlantisColourConstants.ASSEMBLY_SWITCH_DEFAULT, new RGB(0, 0, 128));
		registry.put(AtlantisColourConstants.ASSEMBLY_SWITCH_SELECTED, new RGB(0, 255, 255));
	}

	/**
	 * Creates a new colour registry for this plugin. All of the code for this method was copied from 
	 * org.eclipse.ui.plugin.AbstractUIPlugin.createImageRegistry(), with uses of ImageRegistry converted to ColorRegistry.
	 * @return new colour registry for this plugin
	 */
	protected ColorRegistry createColorRegistry() {
    	//If we are in the UI Thread use that
    	if(Display.getCurrent() != null) {
			return new ColorRegistry(Display.getCurrent());
		}
    	
    	if(PlatformUI.isWorkbenchRunning()) {
			return new ColorRegistry(PlatformUI.getWorkbench().getDisplay());
		}
    	
    	//Invalid thread access if it is not the UI Thread 
    	//and the workbench is not created.
    	throw new SWTError(SWT.ERROR_THREAD_INVALID_ACCESS);
    }

	/** 
	 * Returns a scanner for performing trace document partitioning.
	 * @return a TracePartitionScanner for this application
	 */
	public TracePartitionScanner getTracePartitionScanner() {
		if (tracePartitionScanner == null) {
			tracePartitionScanner = new TracePartitionScanner();
		}
		return tracePartitionScanner;
	}

	public SecurePreferenceStore getSecurePreferenceStore() {
		if (securePreferenceStore == null) {
			ISecurePreferences root = SecurePreferencesFactory.getDefault();
 			ISecurePreferences node = root.node(AtlantisActivator.PLUGIN_ID);
 			securePreferenceStore = new SecurePreferenceStore(node);
		}
 		return securePreferenceStore; 
	}
}