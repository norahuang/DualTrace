\startfirstchapter{Introduction}
\label{chapter:introduction}
The internet grows incredibly fast in the past few year. More and more computers are connected to it in order to get service or provide service. The internet as a powerful platform for people to share resource, meanwhile, introduces the risk to computers in the way that it enable the exploit of the vulnerability of the software running on it.

Accordingly, the emphasize place on computer security particularly in the field of software vulnerabilities increase dramatically. It's important for software developers to build secure applications. Assurance about the integrity and security of the software are expected from the vendors of the software. Unfortunately, building secure software is expensive. The vendors usually comply with their own quality assurance measures which focus on marketable concerns while left security in lower priority or even worse totally ignore it. Therefore, fully relying on the vendor of the software to secure you system and data is unpractical and risky.

Software security review conducted by a third party is usually more convincing and comprehensive. One approach of software security review is software auditing. It is a process of analyzing the code of the software in form of source code or binary. This auditing can uncover some hard to reveal vulnerabilities which might be misused by the hackers. Identification of these security holes can safe the users of the software from putting their sensitive data and business resources at risk.

Most of the software vulnerabilities are caused by malicious data intrusion. So it is valuable to understand how this malicious data trigger the unexpected behaviors of the system. In most of the case this malicious data is injected by an attacker into the system to trigger the exploit. Nonetheless, this malicious data might go through devious path to ultimately triggers an exploitable condition of the system. In some complicated system, several components which are collaborated programs work together to provide service or functionality. In these situation the malicious data might have passed through multiple components of the system and be modified before it reach the vulnerable point of the system. As a consequence, the flow of data throughout the system's different programs is considered to be one of the most important attribute to analysis during the security review.\cite{dowd_art_2006}

The data flow among various programs with in the system or across different systems helps to understand how the system work as well as disclose the vulnerabilities of the system as stated before. There are multiple mechanism to grab the data across programs. And the methods for the grasp of this data flow is essential and can affect the analysis result greatly. For instance, packet capture by some sort of sniffers in the network is considered to be insufficient for security problems detection by the experience security engineer from DRDC(research partner of our group). Instead, dynamic analysis of the programs by capturing and analyzing their execution traces with memory accesses is an relatively accurate to analysis the data transmitted throughout the programs of the system. 

In this research, I developed a method to analysis communications between the programs by the analysis of the execution traces of them. I didn't aim at covering all the communication types but only focus on the data exchanging ones. This method should be able to guide the security engineers to investigate the communications of the programs in the circumstance that they have the captured execution traces and want to understand the interaction behavior of the programs. The research is not specified for vulnerabilities detection but generalized for the comprehension of the behavior of the programs.

\section{Motivation}
This project started with an informal requirement from DRDC for visualizing multiple assembly traces to assist their software and security analysis. The literature review and the conversation with DRDC help to clarify the goal and target of this research. In this section, I discuss the need of performing assembly trace investigation for communication analysis. First I explain why security engineers perform assembly trace analysis. Then I elaborate why they need to perform communication analysis at assembly trace level. Out of the answers of these two questions, I conduct this research.

\subsection{Why Assembly Trace Analysis}
Dynamic analysis of program is adopted mainly in software maintenance and security auditing\cite{zhang2010detecting}, \cite{cai2016sworddta}, \cite{somorovsky2016systematic}. Sanjay Bhansali et al. claimed that program execution traces with the most intimate detail of a program's dynamic behavior can facilitate the program optimization and failure diagnosis. Jonas Tr{\"u}mper et al. give a example of how tracing can facilitate software-maintenance tasks \cite{trumper2012maintenance}.

The dynamic analysis can be done by using debuggers, however, debuggers would halt the execution of the system and result in a distortion of the timing behavior of the running system \cite{trumper2012maintenance}. Instead, tracing a running program with instrumentation would provide more accurate run time behavior information about the system.

The instrumentation of the tracing can be in various level, such as programming language or machine language levels. The choice in some how depends on the accessibility to the application. The application access is divided into five categories with variations: source only, binary only, both source and binary access, checked build, strict black box. Binary only category is common when performing vulnerability research on closed-source commercial software.\cite{dowd_art_2006} In this case, assembly level provides the possibility of the security review of the software. Unavailability of source is the 

On the other hand, since the binary code is actually what is running on the system, it is more representative of what is actually running than the source code.  Some bugs might appear because of a compilation problem or because the compiler optimized away some code that was
necessary to make the system secure. The piece of code list below is an example in which the code line of code resetting the password before the program end would be optimized away by GNU Compiler Collection(GCC) due to it is not used later. This made the user's password stayed in memory, which is considered as a security flaw. However, by looking at the source code didn't reveal that problem.

\begin{lstlisting}[language=C++, caption= Password Fetching Example ]
#include <iostream>
#include <string>
#include <conio.h>
using namespace std;
int main(){
   string password ="";
   char ch;
   cout << "Enter password";
   ch = _getch();
   while(ch != 13){//character 13 is enter
      password.push_back(ch);
      cout << '*';
      ch = _getch();
   }   
   if(checkPass(password)){
     allowLogin();
   }  
   password ="";
}
\end{lstlisting}


\subsection{Why Communication Analysis with Assembly Traces}
Programs nowaday do not alway work isolately,  many software  appear as  reticula collaborating systems connecting different modules in the network\cite{PhysRevE.68.046116} which make the discovery of vulnerabilities even harder. The communication and interaction between modules affect the behavior of the software. Without regarding to the synergy information , analysis of the isolated execution trace on a single computer is usually futile. The tracing data flow process is essential to reviews of both the design and implementation of software.

Many network sniffer such as Wireshark\cite{_wireshark_????} and Tcpdump\cite{tcpdump_tcpdump/libpcap_????} can help to capture the data flow across the network which make the systematic analysis possible. However, it is claimed as the insufficient method due to the fact that security problems can occur even if the information sent is correct. Therefore, analyzing the communications with transmitted data in instruction and memory access level is a solid way to evaluation the system.

Shameng Wen et al. argued that fuzz testing and symbolic execution are widely applied to detect vulnerabilities in network protocol implementations. They present their model-guided approach to detect vulnerabilities in the network protocol implementation. Their work emphasized model which guide the symbolic execution for the fuzz testing while ignoring the analysis of the output, which can be the execution traces, from the execution. \cite{wen2017model} Further more, their work focus only on the network protocol implementation but not generalized to all communication method, including network protocol and inter process communications.

Besides vulnerabilities detection and security reason, communication analysis with assembly traces can also be a way to learn how the work is performed by the system or sometime validate a specification of it. Our research partner DRDC provided use cases of communication analysis which related to their work with embedded system. These systems often have more than one processor, each specialized for a specific task, that coordinate to complete the overall job of that device.  In other cases, the embedded device will work with a normal computer and exchange information with it through some means
(USB, wireless, etc.).  For instance, the data might be coming in from an external sensor in an analog form, transformed by a Digital Signal Processor (DSP) in a device, sent to a more generic processor inside that device to integrate with other data then send wirelessly to an external computer. Being able to visualize more than one trace would help them follow the flow of data through the system.

\section{Approach}
The approach I elaborate in this section is not a forthright process. Instead, it is a back and forth one, for example the implementation changed several times with the changes of the model, and the models was modified based on the understanding throughout the implementation. Here I simply my research approach by listing the key factors in each step while ignoring route of it.

This research requires background knowledge in software security, program communication mechanism and implementation, assembly execution traces. I acquire the software security knowledge basically from literature reviews. It helps me to grab the essential concept of software vulnerabilities and their categories, understand some facilities for vulnerabilities detection and software maintenance in the perspective of security. After that, I was convinced that communication analysis in assembly trace level would benefit software security engineers to understand to behavior of the software and detect software vulnerabilities. 

In order to analysis the communication of programs, I had to know how the communication works. For this purpose, I started the investigation from a piratical experiment by writing example simple programs with the Windows API and run them locally in my desktop. By understanding their behavior and the reading of the Windows API documentation, I abstracted the communication model which is not operating system specific.

The assembly trace model was build on the generalization of the trace format provided by our research partner, DRDC. I don't have the access to their home-made assembly tracer which is based on PIN\cite{_pin_????}. Fortunately, they provides a comprehensive document about the format of the captured trace and example traces to me. With these, I grasped the constructive view of the assembly execution trace. Further more, in the present of some dynamic software analysis works \cite{godefroid2008automated}, \cite{li2013software}, \cite{sailer2016coretana}, \cite{balakrishnan2004analyzing}, \cite{bhansali2006framework} and \cite{trumper2012maintenance}, it is certain that, some other tools can also capture the required information in assembly level for communication analysis. This supports the generalization of the trace format and the abstraction of the dual\_trace modeling.

The implementation of the prototype and the communication identification algorithms are develop in parallel. The high level identification algorithm and the specific algorithms for named pipe communication methods were abstracted based on the implementation, while the others are developed theoretically.

Among the two experiments, the first simpler one was provided directly by DRDC with their initial requirement, while the second one was designed by me. In both experiments, DRDC conducted the program execution and trace capture on their environment while I performed the analysis locally with Atlantis on my desktop with the captured traces and corresponding .dll.


\section{Thesis Organization}
In Chapter 2, I summarize the related background information and knowledge needed to understand or related to this work including security and vulnerability, program communication mechanisms, program execution trace tools, and Atlantis. 

Chapter 3 depicts the model of the communication between two programs and the model of the dual\_trace which contains two execution traces of two interacting program. The communication model defines the communication in the context of trace analysis as well as discusses the properties of the communications. The dual\_trace model not only represents the original format of the execution traces, but also abstract the elements from the original format and matches them to the elements in the communication model. 


Chapter 4 describes the algorithms I developed for the communication analysis of the dual\_trace including the high level communication identification algorithm and the detail ones such as event and stream filtering algorithms, stream matching algorithms and data verification algorithms.

To provide more concrete idea, I present, in chapter 5, the implemented communication identification feature prototype. This prototype was built on top of Atlantis\cite{huang2017atlantis}, an assembly execution trace analysis environment.

In chapter 6, I present two detailed experiments with dual\_traces of programs using named pipe for communication on the implemented prototype. Notably, the result shows the communications are correctly identified. 

Finally, In chapter 7, I conclude the result of this research and outline the possible future work.