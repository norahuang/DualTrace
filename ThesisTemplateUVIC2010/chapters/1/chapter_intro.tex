\startfirstchapter{Introduction}
\label{chapter:introduction}
The internet grows incredibly fast in the past few year. More and more computers are connected to it in order to get service or provide service. The internet as a powerful platform for people to share resource, meanwhile, introduces the risk to computers in the way that it enable the exploit of the vulnerability of the software running on it.

Accordingly, the emphasize place on computer security particularly in the field of software vulnerabilities increase dramatically. It's important for software developers to build secure applications. Assurance about the integrity and security of the software are expected from the vendors of the software. Unfortunately, building secure software is expensive. The vendors usually comply with their own quality assurance measures which focus on marketable concerns while left security in lower priority or even worse totally ignore it. Therefore, fully relying on the vendor of the software to secure you system and data is unpractical and risky.

Software security review conducted by a third party is usually more convincing and comprehensive. One approach of software security review is software auditing. It is a process of analyzing the code of the software in form of source code or binary. This auditing can uncover some hard to reveal vulnerabilities which might be misused by the hackers. Identification of these security holes can safe the users of the software from putting their sensitive data and business resources at risk.

Most of the software vulnerabilities are caused by malicious data intrusion. So it is valuable to understand how this malicious data trigger the unexpected behaviors of the system. In most of the case this malicious data is injected by an attacker into the system to trigger the exploit. Nonetheless, this malicious data might go through devious path to ultimately triggers an exploitable condition of the system. In some complicated system, several components which are collaborated programs work together to provide service or functionality. In these situation the malicious data might have passed through multiple components of the system and be modified before it reach the vulnerable point of the system. As a consequence, the flow of data throughout the system's different programs is considered to be one of the most important attribute to analysis during the security review.\cite{dowd_art_2006}

The data flow among various programs with in the system or across different systems helps to understand how the system work as well as disclose the vulnerabilities of the system as stated before. There are multiple mechanism to grab the data across programs. And the methods for the grasp of this data flow is essential and can affect the analysis result greatly. For instance, packet capture by some sort of sniffers in the network is considered to be insufficient for security problems detection by the experience security engineer from DRDC(research partner of our group). Instead, dynamic analysis of the programs by capturing and analyzing their execution traces with memory accesses is an relatively accurate to analysis the data transmitted throughout the programs of the system. 

\section{Research Goal}
In this research, my goal is to develop a method to analysis communications between the programs by the analysis of the execution traces of them. I didn't aim at covering all the communication types but only focus on the data exchanging ones. This method should be able to guide the security engineers to investigate the communications of the programs in the circumstance that they have the captured execution traces and want to understand the interaction behavior of the programs. The research is not specified for vulnerabilities detection but generalized for the comprehension of the behavior of the programs.

\section{Motivation}
This project started with an informal requirement from DRDC for visualizing multiple assembly traces to assist their software and security analysis. The literature review and the conversation with DRDC help to clarify the goal and target of this research. In this section, I discuss the need of performing assembly trace investigation for communication analysis. First I explain why security engineers perform assembly trace analysis. Then I elaborate why they need to perform communication analysis at assembly trace level. Out of the answers of these two question, it is reasonable for me to conduct this research.

\subsection{Why Assembly Trace Analysis}
Application Access Application access is divided into the five categories listed in Table 4-1. These distinctions are not, of course, absolute. There are always minor variations, such as limited source access or inconsistencies between test environments and deployment environments. However, these distinctions work well enough to cover most possibilities. Table 4-1. Categories of Application Access Category Description Source only Only the source code has been supplied, with no build environment or application binaries. You might be able to build a working binary with some effort, although some required components typically aren't available. As a result, the review is generally done using only static analysis. This type of access is common for contracted application reviews, when the client can provide source but not a functional build or testing environment. Binary only Application binaries have been supplied, but no source code is provided. The application review focuses on live analysis and reverse engineering. This type of access is common when performing vulnerability research on closed-source commercial software. Both source and binary access Both a source tree and access to a working application build are available. This type of access provides the most efficient review possible. It's most common for in-house application assessments, although security- and cost- conscious clients provide this access for contracted reviews, too. The Art of Software Security Assessment - Identifying and Preventing Software Vulnerabilities 106 Table 4-1. Categories of Application Access Category Description Checked build You have an application binary and no source code, but the application binary has additional debugging information. This approach is often taken for contracted code reviews when a client is unwilling to provide source but does want to expedite the review process somewhat. Strict black box No direct access to the application source or binary is available. Only external, blind testing techniques, such as black box and fuzz- testing, are possible with this type of access. It's common when assessing Web applications (discussed more in Chapter 17(? [????.]), "Web Applications").
\subsection{Why Communication Analysis with Assembly Traces}

This process of tracing data flow is central to reviews of both the design and
implementation of software. User-malleable data presents a serious threat to the
system, and tracing the end-to-end flow of data is the main way to evaluate this
threat. Typically, you must identify where user-malleable data enters the system
through an interface to the outside world, such as a command line or Web request.
Then you study the different ways in which user-malleable data can travel through
the system, all the while looking for any potentially exploitable code that acts on the
data. It's likely the data will pass through multiple components of a software system
and be validated and manipulated at several points throughout its life span.
This process isn't always straightforward. Often you find a piece of code that's almost
vulnerable but ends up being safe because the malicious input is caught or filtered
earlier in the data flow. More often than you would expect, the exploit is prevented
only through happenstance; for example, a developer introduces some code for a
reason completely unrelated to security, but it has the side effect of protecting a
vulnerable component later down the data flow. Also, tracing data flow in a real-world
application can be exceedingly difficult. Complex systems often develop organically,
resulting in highly fragmented data flows. The actual data might traverse dozens of
components and delve in and out of third-party framework code during the process of
handling a single user request.

Programs nowaday do not alway work isolately,  many software  appear as  reticula collaborating systems connecting different modules in the network\cite{PhysRevE.68.046116} which make the discovery of vulnerabilities even harder. The communication and interaction between modules affect the behaviour of the software. Without regarding to the synergy information , analysis of the isolated execution trace on a single computer is usually futile. Many network sniffer such as Wireshark\cite{_wireshark_????} and Tcpdump\cite{tcpdump_tcpdump/libpcap_????} can help to capture the data streams flow across the network which make the systematic analysis possible.\\


\section{Approach}
In this work, I first modeled the communication between two programs. This model defines the communication objects under investigate and identified in the dual\_trace. In simplification, a communication is completed between two programs each of which corresponds to a sequence of events. An event can be one four different event type(channel open, data send, data receive and channel close). However the actual events are various according to the communication method and the user concern. Then, I modeled the dual\_trace, excluding the irrelevant information while abstracting the information related to the communications. Furthermore, I investigated the implementation of the communication methods in Windows. The result of the investigation provides some guidelines and examples of how to draw the concerned event list as described in the communication model which is the prerequisite of the communication identifications. By matching the elements in the communication model and the dual\_trace model, I developed the communication identification algorithms. To provide more concrete idea, I implemented the communication identification features in Atlantis\cite{huang2017atlantis}, an assembly execution trace analysis environment.

Finally, I tested the models and the algorithms by two experiments. The experiment result shows that 1) the existing dual\_trace contain sufficient information for communication analysis based on the designed models. In addition. 2) the developed algorithm can effectively identify the communications from the dual\_trace. This work is a collaborative work with our research partner DRDC. In the experiment tests, DRDC captured the dual\_traces with its home-make pin tool of the programs running in DRDC's environment. I conducted the analysis of the provided dual\_traces as long as the dynamic libraries of the running environment locally.

\section{Thesis Organization}
