\externaldocument{../3/chapter_modeling}
\externaldocument{../5/chapter_implementation}
\externaldocument{../appendix/chapter_app}
\startchapter{Communication Identification Algorithms}
\label{chapter:alo}
The goal of this work is to identify the communications from the dual\_trace. A dual\_trace is a pair of assembly level execution traces of two interacting programs. In this chapter, I discuss the characteristics of the execution trace and give the abstract definition of the execution trace. Based on the communication model in Chapter\ref{chapter:Mod}, I developed the algorithms for communication identification from dual\_trace. Traces captured by different tracers can be analyzed with these developed algorithms, as long as the traces comply the abstract trace definition.

\section{Dual\_Trace}
A dual\_trace consists of two assembly level execution traces of two interacting programs. There is no timing information of these two traces which means we don't know the timing relationship of the events of one trace with respect to the other. However the captured instructions in the trace are ordered in execution sequence. An execution trace consist of a sequence of executed instruction lines. Each instruction line contains the executed instruction, the changed memories, the changed registers, execution information. The execution info indicate the execution type which can be: Instruction, System call entry, System call exit, etc. For the execution type of system call entry and system call exit, system call Id is given in this information. With the system call id and the provided .dll files, the called system function name can be obtained. 

Based on the characteristics of the execution trace, a dual\_trace is defined as :

$dual\_trace = \lbrace trace_0, trace_1\rbrace$

where $trace_0$ and $trace_1$ are two assembly execution traces of two interacting programs.

A trace is a sequence of executed instruction line. Hence, we can define a trace $trace$ as a sequence of $n$ instruction lines:

$ trace = (l_1, l_2, ..., l_n)$ 

Each instruction line, $l$ is a tuple:

$l = <ins, mch, rch, exetype, syscallInfo>$

where $ins$ is the instruction, $mch$ is the memory changes, $rch$ is the register changes, $exetype$ is the execution type which can be instruction, system call entry, system call exit, and other types which are not concerned, $syscallInfo = <exeName, offset>$ only appear when $exetype$ is system call entry or system call exit. $exeName$ is the executable file(e.g .dll and .exe) name, while $offset$ is the offset of the system function in this executable file.

Figure\ref{trace} is an example of a piece of execution trace comply to this definition. Some executed instructions are hidden to highlight the characteristic of the trace. 

\begin{figure}[H]
\centerline{\includegraphics[scale=0.5]{Figures/trace}}
\caption{An example trace }
\label{trace}
\end{figure}

Figure\ref{executable} is an example of the information decoded from a executable file kernal32.dll, from which the function name can be obtained by the offset.

\begin{figure}[H]
\centerline{\includegraphics{Figures/executable}}
\caption{Information of kernal32.dll}
\label{executable}
\end{figure}

\section{Function Event Reconstruction Algorithm}
In last section, I define the assembly execution trace. As to this definition, it is possible to recognize the function call and function call return from the trace.  In this section, I define the function event and discuss the algorithm to reconstruct the function events from the assembly execution trace. 


There would be lots of function calls in an execution trace while most of them are not of interest. This algorithm will only reconstruct those function calls of interest. To be able to identify the functions of interest, function descriptions is required. The function descriptions are:

A list of function description, each description includes a function name, a function type indicator and a function description. The function type indicator is marked as one of the four types: channel open, channel close, send and receive events. This indicator is not needed in this algorithm but will be heritaged for the stream extration algorithm. The function description illustrate how the current registers and memory contents map to a given function call and the list of its parameter of interest(you might not care for all parameters). By memory reconstruction\cite{cleary_reconstructing_2013}, the parameters and return value of the function call can be computed from the execution trace. Table\ref{functionexample} is an example of an element in the function descriptions. In this example, the function name is ReadFile, it is a function for data receiving. The description includes the concerned parameters, which are File Handle, Send Buffer and Message Length. The File Handle is a input parameter which is a value stored in the register RCX. The Send Buffer is an address for the input message stored in the register RAX. The Message Length is a output value stored in register R9. The value of the input parameters can be retrieved from the memory reconstruction on the function call instruction line while the value of the output parameters can be retrieved from the memory reconstruction on the function return instruction line. If a parameter is a address instead of value, the address should be retrieved first, then the retrieved address should be used to find the buffer content in the memory reconstruction result as well.  The function description requires the understanding of the calling convention of the operating system. More example will be given in Chapter\ref{chapter:newsol}.

\begin{table}[H]
        \centering
        \caption{An example of a function description}
        \label{functionexample}
        \begin{tabular}{|l|l|l|l|l|l|}
            \hline
             \multirow{2}{*}{{\textbf{Name}}} & \multirow{2}{*}{{\textbf{Type}}} & \multicolumn{4}{c|}{\textbf{Description}}  \\
              \cline{3-6} 
             & & \textbf{Parameter}& \textbf{Register/Stack Position}& \textbf{In or Out} &  \textbf{Buffer Or Value}  \\
             \hline
             \multirow{3}{*}{ReadFile}
             &\multirow{3}{*}{data receive} &  FileHandle & RCX & In & Value\\
              \cline{3-6} 
             & & SendBuffer & RDX & In & Address\\
              \cline{3-6} 
             & & MessageLength & R9 & Out & Value\\
            \hline            
        \end{tabular}
    \end{table}

With the function descriptions and the execution trace as input, the function event reconstruction algorithm outputs all the function call events from the execution trace. A function call event is defined as a tuple:

$ev = <funN, paras, type>$

where $funN$ is the function name, $paras$ includes the parameters' name and value and $type$ is the event type which can be one of the four types: channel open, data send, data receive and channel close.

Note: if the parameter is an address, the value is the string from the buffer pointed by this address instead of the address value.

The output of the function event reconstruction algorithm $etr$ is a sequence of function call events which can be defined as:

$etr = (ev_1, ev_2, ..., ev_m)$

An example of a sequence of function call events as the output of this algorithm is listed in Listing\ref{eventsexample}

\begin{lstlisting}[caption= Example of  $etr$]
\label{eventsexample}
$ev_1 : CreateNamedPipe;  FileHandler=18,  File Name="mypipe"; type=channel open
$ev_2 : CreateNamedPipe;  FileHandler=27,  File Name="Apipe"; type=channel open$
$ev_3 : WriteFile; FileHandler=27, RecvBuffer="Message 1", MessageLength=9; type=data send$
$ev_4 : WriteFile; FileHandler=27, RecvBuffer="Message 2", MessageLength=9; type=data send$
$ev_5 : ReadFile; FileHandler=27, SendBuffer="Message 3", MessageLength=9; type=data receive$
$ev_6 : CloseHandle; FileHandler = 27; type=channel close$
$ev_7 : CloseHandle; FileHandler = 18; type=channel close$
\end{lstlisting}

The function event reconstruction algorithm is listed in Algorithm\ref{eventAlg}. Since the function descriptions usually contain a  small number of concerned functions compared to the instruction line number in the execution trace, the time complexity of this algorithm is O(N) , N is the instruction line number of the trace.

\begin{algorithm}[H]
\DontPrintSemicolon
\caption{{\bf Function Event Reconstruction Algorithm} \label{eventAlg}}
\KwIn{ $trace, function descriptions$}
\KwOut{$etr$}
$etr \leftarrow \emptyset$\; 
Emulate the Execute of each instruction line of the trace;\;
\If{The instruction is a call to a function in the $function descriptions$}{
   Create an new function event $ev$;\;
   $ev.funN  \leftarrow$ Function Name;\;
   $ev.type \leftarrow$ 
   Append all the input parameters of interest to $ev.paras$;\;
   Continue the emulation until the function call return line;\;
   Append all the output parameters of interest to $ev.paras$;\;
   Append $ev$ to $etr$;\;
}
\KwRet $etr$;\;
\end{algorithm} 


\section{Stream Extraction Algorithm}
The events located in the $etr$ may belong to different stream, the next step in the communication identification algorithm is to identify them for each stream. The input of this algorithm the $etr$ from the ``Event Locating Algorithm". Since the input  $etr$ is sorted by time of occurrence and the channel open events should always happen before other events, it is reasonable to assume the new stream can be identified by its first channel open function call. The identification for TCP and UDP server endpoints are slightly complicated than the other ones, due to its own channel open mechanism. The output of this algorithm is the $str$. Each stream in this $str$ consist of the sub streams. The concepts of the stream and sub streams are defined in Section\ref{term}. 

\begin{algorithm}[H]
\DontPrintSemicolon
\caption{{\bf Stream Indentification Algorithm} \label{endpointIdentAlg}}
\KwIn{$etr$}
\KwOut{$str$}
$str \leftarrow Map \langle h, s\rangle$;\; 
\For{$ev \in etr$}{
   \If{$ev$ is a channel open event}{
      $h \leftarrow$ get the handle identifier from the function parameter list;\;
      $s \leftarrow str.get\left( handle \right)$;\;
      \If{$ev$ is an $accept\left( \right)$ function call for TCP or UDP}{
         $h1 \leftarrow$ get the second socket handle identifier from $ev.out$;\;
         $str.remove\left( h \right)$;\;
         $str.add\left( h1, s \right)$;\;
      }
      
      \If{$s$ is null}{
         New a stream $s$;\;
         $str.add\left( h, s \right)$;\;
      }
      $ss.so.add\left( evs \right)$;\;
   }
   \If{$ev$ is a channel send event}{
      $h \leftarrow$ get the handle from the function parameter list;\;
      $s \leftarrow str.get\left( h \right)$;\;
      \If{$s$ is not $null$ and $s.complete$ is $False$}{
         $s.ss.add\left( ev \right)$;\;
      }
   }
   \If{$ev$ is a channel receive event}{
      $h \leftarrow$ get the handle from the function parameter list;\;
      $s \leftarrow str.get\left( h \right)$;\;
      \If{$s$ is not $null$ and $s.complete$ is $False$}{
         $s.sr.add\left( event \right)$;\;
      }
   }
   \If{$ev$ is a channel close event}{
      $h \leftarrow$ get the handle from the function parameter list;\;
      $s \leftarrow str.get\left( h \right)$;\;
      \If{$s$ is not null}{
         $s.sc.add\left( ev \right)$;\;
         $s \leftarrow True$;\;
      }
   }         
}
\KwRet $str$;\;
\end{algorithm} 

\section{Stream Matching Algorithm}\label{streammatch}
The communication identification algorithm aims at identifying all the communication of a concerned communication method from the dual-trace. The input of this algorithm is the two $str$ from the dual-trace. The output of this algorithm is the communication list. Each communication recognized from the dual\_trace contains two streams. The channel of a communication defined in Section\ref{definition} is not explicitly represented in the output but it was implicitly used in this algorithm. 

In the communication identification algorithm, it first try to match two streams to a channel only by their identifiers. In this level, the matching depends on channel open mechanisms which are different from communication method to communication method. For TCP and UDP the matching can be considered as local address and port of server endpoint matching with remote address and port of client endpoint. For Named Pipe, it uses the file name, while for Message Queue, it uses the queue name as the identifier for matching of two endpoints. 

The first level matching can not guarantee the exact endpoints matching and channel identification. There are two situations which false negative error might emerge. Take Named Pipe for example, the first situation is multiple(more than two) interacting programs shared the same file or queue as their own channel. Even though the channels are distinct for each communication, but the file or queue used is the same one. For example, the Named Pipe server is connected by two clients using the same file. In the server trace, there are two streams found. In each client trace, there is one stream found. For the dual\_trace of server and client1, there will be two possible identified communications, one is the real communication for server and client1 while the other is the false negative error actually is for server and client2. The stream in client1's trace will be matched by two streams in the server's trace. The second situation is the same channel is reused by the different endpoints in the same programs. For example, the Named Pipe server and client finished the first communication and then closed the channel. After a while they re-open the same file again for another communication. Since the first level matching is only base on the identifiers and the first and the second communications have the same identifier since they used the same file. Similar situations can also happen in Message Queue, TCP and UDP communication methods. 

To reduce the false negative error, the second level matching should be applied, which is also being named as transmitted data verification algorithm. On top of the endpoint identifiers matching, further data verification should be applied to make sure the matching is reliable. This verification crossly compare the sent and received data in both streams in the first level matching. If the transmitted data in the streams are considered to be identical, the matching is confirmed, otherwise it was a false negative error. However, we still can not exclude all the false negative errors, due to the data transmitted in two communication can be identical. Figure\ref{secondlevelmatching} indicates the ineffective second level matching scenario and the effective one.

\begin{figure}[H]
\centerline{\includegraphics[scale=0.55]{Figures/secondlevelmatching}}
 \caption{Second Level Matching Scenarios}
\label{secondlevelmatching}
\end{figure}


The following subsections discuss the algorithms for these two level matching. In Section\ref{windows}, I elaborate the channel open process and the data transfer categories for the concerned communication methods. Based on the different channel opening process, two algorithms are developed for the communication identification, one is for Named Pipe and Message Queue, the other is for TCP and UDP. The inputs of the these two algorithms are the same, two $str$s from the original dual\_trace.

The data transfer characteristics divided the communication methods into reliable and unreliable transmissions. Named Pipe and TCP fall in the reliable category while Message Queue and UDP fall in the unreliable one. The second level matching algorithms are different for these two categories. The corresponding second level data verification algorithms are being used in the communication identification algorithms. The inputs of the transmitted data verification algorithms are streams matched in the first level matching while the output a boolean to indicate if the transmitted data of this two streams are matched and the verified data.

\subsection{Stream Matching Algorithm for Named Pipe and Message Queue}
For Named Pipe and Message Queue, only one channel open function is being called in each $s$. So in the below algorithm, when it try to get the channel open event from the $s.so$ list, only one event should be found and return. The channel identifier parameters can be found in the $ev.in$ of the channel open event. The identifier for Named Pipe is the file name of the pipe while for Message Queue is the format queue name of the queue. This algorithm finds out all the possible communications regardless some of them might be false negative errors. 

\begin{algorithm}[H]
\DontPrintSemicolon
\caption{{\bf Stream Matching Algorithm for Named Pipe and Message Queue} \label{channelAlg1}}
\KwIn{$str0, str1$}
\KwOut{$cs = \left\lbrace c_1, c_2...c_n\right\rbrace $}
$cs \leftarrow$ empty communication list;\;
\For{$s0 \in str0$}{
   $openev0 \leftarrow$ get the opening event from $s0.so$;\;
   $chId0 \leftarrow$ get the channel identifier from $openev0.in$;\;
   \For{$s1 \in str1$}{
      $openev1 \leftarrow$ get the opening event from $s1.so$;\;
      $chId1 \leftarrow$ get the channel identifier from $openev1.in$;\;
     \If{$chId0 == chId1$}{
         $DataVerified = dataVerify(s0, s1, outputdata)$;\;
         \If{$DataVerified == True$}{
            $c.stream0 = stream0$;\;
            $c.stream1 = stream1$;\;
            $c.dataMatch = outputdata$;\;
            $cs.add\left( c \right)$;\;
         }    
      }
   }
}
\KwRet $cs$;\;
\end{algorithm} 


\subsection{Stream Matching Algorithm for TCP and UDP}
For TCP and UDP multiple functions are collaborating to create the final communication channel. The local address and port of the server endpoint and the remote address and port of the client endpoint are used to identify the channel. This algorithm first try to retrieve the local address and port of the server endpoint and remote address and port from client endpoint. Then it try to match two endpoints by comparing the local and remote address and port. Transmitted data verification also applied in this algorithm.

\begin{algorithm}[H]
\DontPrintSemicolon
\caption{{\bf Stream Matching Algorithm for TCP and UDP} \label{channelAlg2}}
\KwIn{$str0, str1$}
\KwOut{$cs = \left\lbrace c_1, c_2...c_n\right\rbrace $}
$cs \leftarrow$ empty communication list;\;
\For{$s0 \in str0$}{
   $socketev0 \leftarrow$ get the $socket\left( \right)$ event from $str0.so$;\;
   $bindev0 \leftarrow$ get the $bind\left( \right)$ event from $str0.so$;\;
   $connectev0 \leftarrow$ get the $connect\left( \right)$ event from $str0.so$;\;
   \For{$s1 \in str1$}{
      $socketev1 \leftarrow$ get the $socket\left( \right)$ event from $s1.so$;\;
      $bindev1 \leftarrow$ get the $bind\left( \right)$ event from $s1.so$;\;
      $connectev1 \leftarrow$ get the $connect\left( \right)$ event from $s1.so$;\;
    \If{$socketev0 !=null$ AND $socketev != null$}{
       \If{$bindev0 != null$ AND $connectev1 == null$}{
           $localServerAddr \leftarrow$ get serverAddr from $bindev1.in$;\;
       }
       \ElseIf{$bindev1 == null$ AND $connectev0 != null$}{
           $remoteServerAddr \leftarrow$ get serverAddr from $connectev1.in$;\; 
       }
       \Else{
          Break the inner For loop;\;
       }
       \If{$localServerAddr == remoteServerAddr$}{
          $DataVerified = dataVerify(stream0, stream1, outputdata)$.
          \If{$DataVerified == True$}{
            $c.s0 = s0$;\;
            $c.s1 = s1$;\;
            $c.dataMatch = outputdata$; 
            $cs.add\left( c \right)$;\;
          }
       }
    }
   }
}
\KwRet $cs$;\;
\end{algorithm}

\subsection{Data Verification $dataVerify()$ for Named Pipe and TCP}
As described in Section\ref{reliable}, the data being received by one endpoint should always equal to or at least is sub string of the data being sent from the other endpoint in a communication for the reliable transmission methods, such as Named Pipe and TCP. So the data verification algorithm is in data union level. The send data union is retrieved by the concatenation of the input buffer content of the send events in the send stream of an endpoint. The receive data union is retrieved by the concatenation of the output buffer content of the receive events in the receive stream of the other endpoint. The input of this algorithm is the two $stream$s from two traces which are being matched in the first level.

\begin{algorithm}[H]
\DontPrintSemicolon
\caption{{\bf Transmitted Verification by Data Union} \label{dataAlg1}}
\KwIn{$s0, s1$}
\KwOut{send data union and receive data union of two streams}
\KwRet{Indicator of if transmitted data union are considered to be identical}\;
$send1 \leftarrow$ empty string;\;
$send2 \leftarrow$ empty string;\;
$recv1 \leftarrow$ empty string;\;
$recv2 \leftarrow$ empty string;\;
\For{$sendEvent \in s0.ss$}{
   $sendmessage \leftarrow$ get the input buffer content from the $sendEvent.in$;\;
   $send0.append\left( sendmessage \right)$;\;
}
\For{$sendEvent \in s1.ss$}{
   $sendmessage \leftarrow$ get the input buffer content from the $sendEvent.in$;\;
   $send1.append\left( sendmessage \right)$;\;
}
\For{$recvEvent \in s0.sr$}{
   $recvmessage \leftarrow$ get the output buffer content from the $recvEvent.out$;\;
   $recv0.append\left( sendmessage \right)$;\;
}
\For{$recvEvent \in s1.sr$}{
   $recvmessage \leftarrow$ get the output buffer content from the $recvEvent.out$;\;
   $recv1.append\left( sendmessage \right)$;\;
}
\If{$recv0$ is substring of $send1$ AND $recv1$ is substring of $send0$ }{
   \KwRet True;\;
}
\Else{
    \KwRet False;\;
}

\end{algorithm} 

\subsection{Data Verification $dataVerify()$ for MSMQ and UDP}
For the unreliable communication methods, the data packets being transmitted are not delivery and ordering guaranteed. So it is impossible to verify the transmitted data as a whole chunk. Fortunately, the packets arrived to the receivers are always as the original one from the sender. Therefore, we perform the transmitted data verification by single events instead of the whole stream. This algorithm basically goes through events of the $ss$ in one stream trying to find the matched receive event in the $sr$ in the other stream. And then calculate the fail packet arrival rate. The fail packet arrival rate should be comparable to the packet lost rate. So we set the packet lost rate as the threshold to determine if the transmitted data can considered to be identical in both directions. The packet lost rate can be various from network to network or even from time to time for the same network. The inputs of this algorithm are the copies of two streams from two traces which are being matched and the packet lost rate as the threshold. I use copies instead of original data is to modify the input list directly in the algorithm. The threshold should be an integer. For example if the lost rate is 5\%, the threshold should be set as 5. 

\begin{algorithm}[H]
\DontPrintSemicolon
\caption{{\bf Transmitted Verification by Data of Events } \label{dataAlg2}}
\KwIn{$s0, s1$}
\KwOut{matched event list of two endpoints}
\KwRet{Indicator of if transmitted data union are considered to be identical}\;
$sendPktNum0 \leftarrow s0.ss.length$;\;
$sendPktNum1 \leftarrow s1.ss.length$;\;
$recvPktNum0 \leftarrow 0$;\;
$recvPktNum1 \leftarrow 0$;\;
$eventMatchs \leftarrow List \langle EventMatch \rangle$;\;
\For{$sendEvent \in s0.ss$}{
   $sendmessage \leftarrow$ get the input buffer content from the $sendEvent.in$;\;
   \For{$recvEvent \in s1.sr$}{
      $recvmessage \leftarrow$ get the output buffer content from the $recvEvent.out$;\;
      \If{$sendmessage == recvmessage$}{
         $recvPktNum0++$;\;
         $stream1.sr.remove\left( recvEvent \right)$;\;
         $eventMatch = New eventMatch\left( \right)$;\;
         $eventMatchs.add\left( eventMatch \right)$;\;
      }
   }
}

\If{$ \left(sendPktNum0-recvPktNum0\right)*100/sendPktNum0 > threshold$}{
 \KwRet False;\;
}

\For{$sendEvent \in s1.ss$}{
   $sendmessage \leftarrow$ get the input buffer content from the $sendEvent.inputs$;\;
   \For{$recvEvent \in s0.sr$}{
      $recvmessage \leftarrow$ get the output buffer content from the $recvEvent.out$;\;
      \If{$sendmessage == recvmessage$}{
         $recvPktNum1++$;\;
         $s0.sr.remove\left( recvEvent \right)$;\;
      }
   }
}

\If{$ \left(sendPktNum1-recvPktNum1\right)*100/sendPktNum1 > threshold$}{
 \KwRet False;\;
}
 \KwRet True;\;
\end{algorithm}

\section{Relationship between Communication Model and Dual-Trace Model}
The identification of the communication from dual\_trace can be simply abstracted as finding the elements of each communication as defined in the communication model from the dual\_trace. 

A communication is defined as $c =<ch, e0, e1>$ while a dual\_trace is defined as $dtr = \lbrace tr0, tr1\rbrace$. In the dual\_trace model, a trace $tr$ can also be represented as stream trace $str = \lbrace s_1, s_2, ..., s_p\rbrace$. In the communication model, $ e =<handle, d_r, d_s>$. 

Each stream in $str$ contains four sub stream: $so, ss, sr, sc$.  The $handle$ of $e$ and $ch$ in $c$ can be acquired from the events in $so$. $d_r$ can be obtain from $sr$ while $d_s$ can be obtained from $ss$. And $pkg$ in the data stream in the communication model has a one to one relationship with $ev$ in the data send and receive stream in the dual\_trace model.

By understanding this relationship, I am optimistic that as long as I can retrieve all the elements defined in the trace in dual\_trace model, there will be a way to identify the communication. In next chapter algorithms for communication identification will be discussed in detail. 


\section{Communication Identification Algorithm}
The identification of the communications from a dual\_trace should be able to identify the concerned communications as well as all the components defined in it. The inputs of this algorithm are the $dual\_trace=\left\lbrace tr0, tr1 \right\rbrace $ and the concerned communication method's function set $fset = \left \lbrace f_1,f_2...f_m \right\rbrace $. The output of this algorithm is all the identified communications of the concerned communication method. This is a very high level algorithm, details of each step in this algorithm will be discussed in the later sections.\par
\begin{algorithm}[H]
\DontPrintSemicolon
\caption{{\bf Communication Identification Algorithm} \label{endpointIdentAlg}}
\KwIn{$dual\_trace$, $fset$}
\KwOut{$cs = \left\lbrace c_1, c_2...c_n\right\rbrace $}
$i = 0;$\;
\For{$tr \in dual\_trace$}{
   $etri = eventfilter\left( tr, fset\right)$;\;
   $stri = streamfilter\left( etr \right)$;\;
}
$cs = streammatch(str0, str1)$;\;
\KwRet $cs$;\;
\end{algorithm} 
