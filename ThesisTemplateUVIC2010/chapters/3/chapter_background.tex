\startchapter{Channel Modeling}
\label{chapter:Bac}

In this section we model four different communication channels based on the windows APIS. The modeling is simplified as much as possible to only get the enough information for the communication event locating. Necessary Assembly calling conventions will be introduced in the section for the purpose of understanding the modeling.

\section{Assembly Calling Convention}
Before we jumping into a specific communication channel, it is important to know some basic assembly calling convention.
Calling Convention is different for operating system and the programming language. Since we are looking into the messaging methods being used in windows communication framework, and since our case study is running on a Microsoft* x64 system, we only list the Microsoft* x64 calling convention for interfacing with C/C++ style functions:\par
\begin{enumerate}  
\item RCX, RDX, R8, R9 are used for integer and pointer arguments in that order left to right.
\item XMM0, 1, 2, and 3 are used for floating point arguments.
\item Additional arguments are pushed on the stack left to right. \ldots 
\item Parameters less than 64 bits long are not zero extended; the high bits contain garbage.
\item Integer return values (similar to x86) are returned in RAX if 64 bits or less.
\item Floating point return values are returned in XMM0.
\item Larger return values (structs) have space allocated on the stack by the caller, and RCX then contains a pointer to the return space when the callee is called. Register usage for integer parameters is then pushed one to the right. RAX returns this address to the caller.
\end{enumerate}

\section{Modeling}
We model four base communication channels used in Windows operating system in this section. They are Named pipe, MQMS, TCP/UDP socket and HTTP channels
\subsection{Named pipes Channel}
A named pipe is a named, one-way or duplex pipe for communication between the pipe server and one or more pipe clients. All instances of the named pipe share the same pipe name, but each instance has its own buffers and handlers. In here we only consider one to one server/client pairs. One server to multiple clients scenario can always be broken into multiple server/client pairs. To locate a named pipe message event in dual-trace, we need to know how the channels are created as well as how the messages are send and received in the assembly traces. The creation of a named pipe will return the handler of that pipe. This handler will be used later on when messages are being sent or received. So we need to know the function calls for named pipe creation and message send/receive to locate the event in the traces. In the follow subsections, we will list the related functions for the named pipe channel for both synchronous mode and asynchronous mode. The create channel functions for both modes are the same but with different input parameters. The functions for send and receive message are also the same for both case. However, the operation of the send and receive functions are different for different mode. In addition, extra function are being called to check the status of message sending or receiving in asynchronous mode as well as the message content.
\subsubsection{Synchronous}
We list all the functions that needed to locate an messaging event in a dual-trace in Table\ref{synfunctions} for synchronous named pipe. The Channel Create Functions indicate how the channel being created in server and client sides, and the mattered parameters. For named pipes the channel create functions are different between in server and client. The parameter in RDX can indicate if the channel is opened as synchronous mode. The send or receive message functions are the same in server and client. When the channel is being created, the input file names for a channel at server and the client are the same, but the returned File Handler IDs are different. The send and receive function only use the handler to send and receive message to a specific channel. 
\begin{table}[h]
        \centering
        \caption{Functions for communication type definition of synchronous named pipe}
        \label{synfunctions}
        \begin{tabular}{|l|l|l|l|l|l|l|}
            \hline
             \multirow{2}{*}{} &
               \multicolumn{2}{c|}{Channel Create Functions} &
               \multicolumn{2}{c|}{Message Send Functions} &
               \multicolumn{2}{c|}{Message Receive Functions} \\
             \cline{2-7}
              & Function& Parameters & Function & Parameters  & Function & Parameters\\
             \hline
             Sever& Create-&  RAX: File Handler &  &  RCX: File Handler &&RCX: File Handler\\
             \cline{3-3} \cline{5-5} \cline{7-7}
             &NamedPipe&RCX: File Name && RDX:  &&RDX: \\
              \cline{3-3} 
             &&RDX: Asyn/Syn&WriteFile & Buffer Address &ReadFile&Buffer Address\\
                \cline{1-3} \cline{5-5} \cline{7-7}
             Client & CreateFile & RAX: File Handler & &  R8: Buffer Length &&R8: Buffer Length\\
              \cline{3-3} \cline{5-5} \cline{7-7}
             &&RCX: File Name &&Stack:&&Stack:\\
             \cline{3-3} 
             &&RDX: Asyn/Syn&& Overlap Pointer&&Overlap Pointer\\
            \hline
        \end{tabular}
    \end{table}
\subsubsection{Asynchronous}
The functions used in Asynchronous mode for create channel, send and receive message are the same as those used in synchronous mode. However,  the ReadFile and WriteFile functions run asynchronously when the channel is asynchronous. This means the function will return immediately, even if the operation has not been completed. If the operation is complete when the function returns, the return value indicates the success or failure of the operation. Otherwise the functions return zero and GetLastError returns ERROR\_IO\_PENDING. In this case, the calling thread must wait until the operation has finished. The calling thread must then call the GetOverlappedResult function to determine the results. This means besides looking for ReadFile and WriteFile function calls in the traces, the GetOverlappedResult function should be checked in the traces to get the full result of the ReadFile or WriteFile operations. Table\ref{asynfunctions} list the interested parameters of the GetOverlappedResult funciton. However, it's complicated to define the communication types with so many functions for only an event. In order to make the user interface clear and simple. We ask the user to make separate definition for the follow function with the send function as a new communication type. Table \ref{Additionalfunction} shows the addition communication type for asynchronous mode.

\begin{table}[h]
        \centering
        \caption{Functions for addition communication type definition of asynchronous named pipe}
        \label{synfunctions}
        \begin{tabular}{|l|l|l|l|l|l|l|}
            \hline
             \multirow{2}{*}{} &
               \multicolumn{2}{c|}{Channel Create Functions} &
               \multicolumn{2}{c|}{Message Send Functions} &
               \multicolumn{2}{c|}{Message Receive Functions} \\
             \cline{2-7}
              & Function& Parameters & Function & Parameters  & Function & Parameters\\
             \hline
             Sever& Create-&  RAX: File Handler &  &  RCX: File Handler &&RCX: \\
             \cline{3-3} \cline{5-5} 
             &NamedPipe&RCX: File Name && RDX:  && File Handler\\
              \cline{3-3} 
             &&RDX: Asyn/Syn&WriteFile& Buffer Address &GetOverlapped-&\\
                \cline{1-3} \cline{5-5} \cline{7-7}
             Client & CreateFile & RAX: File Handler & &  R8: Buffer Length &Result&RDX:\\
              \cline{3-3} \cline{5-5} 
             &&RCX: File Name &&Stack:&&Overlap\\
             \cline{3-3} 
             &&RDX: Asyn/Syn&& Overlap Pointer&&structure\\
            \hline
        \end{tabular}
    \end{table}
    

\subsection{MQMS Channel}
\subsubsection{Synchronous}
\subsubsection{Asynchronous}

\subsection{TCP/UDP Socket Channel}
\subsection{HTTP Channel}


