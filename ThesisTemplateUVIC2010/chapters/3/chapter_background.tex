\startchapter{Background}
\label{chapter:Bac}
In this section, we introduce several background knowledge or information that related to this work. First we describe what is software security and how important it is as well as our previous approach to assist detection of software vulnerabilities by assembly level trace analysis. Second, we introduce the general assembly level trace format as well as some tracer to generate it. Third, we discuss how software interaction affect the behavior of the software and how they related to the software vulnerabilities. Then we talk about Windows Communication Foundation in which the communication channel type used are targeted by this work. Finally, we mention some important Windows function calling conventions without which you can not picture what the function calls look like in the assembly level.
\section{Software security}
The internet grow incredibly fast in the past few year. More and more computers are connected to it in order to get service or provide service. The internet as a powerful platform for people to share resource, meanwhile, introduce the risk to computers in the way that it enable the exploit of the vulnerability of the software running on it. Accordingly, the emphasize place on computer security particularly in the field of software vulnerabilities increase dramatically. It's important for software developers to build secure applications. Unfortunetely, this is usually very expensive and time consuming and somehow impossible in some cases. On the other hand, how to find issues in the built applications is more important and practical. Howerver this is a complex process and require deep technical understanding in the perspetive of reverse engineering\cite{dowd_art_2006}.


\section{Software Vulnerability Detection}
A common approach to detect existing vulnerabilities is fuzzing testing, which record the execution trace while supplying the program with input data up to the crash and perform the analysis of the trace to find the root cause of the crash and decide if that is a vulnerability\cite{cleary_reconstructing_2013}. Execution trace can be capture in different level, for example object level and function level. But my research only focus on those that captured in instruction and memory reference level. There are two main reasons for analysis system-level traces. The first one is for analysis of the software provided by vendor whose source code are not available. The second one is that low level trace are more accurately reflect the instructions that are executed by multicore hardware\cite{wang_predicting_2011}.

Nonetheless, analysis and visualization of the enormous amount of execution information of a isolated software is complicated let alone the additional interactive information between applications. My first research goal is to develop a comprehensive method to analyse and visualize of massive execution traces of multiple interacting applications in order to  assist vulnerabilities detection. 

Moreover, in order to eliminate the laborious work for reverse engineer in the procedure of discovering vulnerability, I also aimed at develop a method or algorithm to auto detect suspicious vulnerabilities before the reverse engineer can take a more careful look on them.

\section{Assembly Level Trace}
There are many tools that can trace a running program in assembly instruction level.  IDA pro \cite{eagle_ida_2008} is a widely used tool in reverse engineering which can capture and analysis system level execution trace. Providing open plugin APIs, IDA pro allows plugin such as Codemap \cite{_c0demap/codemap:_????} to provide more sufficient features for "run-trace" visualization. However this trace events from IDA pro are stored in buffer. Depends on the size of your computer memory, it may not able to trace and analysis a big program for a long time. PIN\cite{_pin_????} as a tool for instrumentation of programs, provides a rich API which allows you to implement your own tool for instruction trace and memory reference trace. 
\section{Software Interaction}
Applications nowaday do not alway work isolately,  many software  appear as  reticula collaborating systems connecting different modules in the network\cite{PhysRevE.68.046116} which make the discovery of vulnerabilities even harder. The communication and interaction between modules affect the behaviour of the software. Without regarding to the synergy information , analysis of the isolated execution trace on a single computer is usually futile. 

\section{Windows Communication Foundation}
We limited our research only on the communication types used in Windows Communication Foundation(WCF) for now. Windows Communication Foundation (WCF) is a framework for building service-oriented applications. Using WCF, developers can send data as asynchronous or asynchronous messages from one service endpoint to another. We are not going deep into the details of this framework but only mention the most common communication methods it supports in its messaging layer. The messaging layer in WCF is composed of channels. A channel is a component that processes a message in some protocol. There are two types of channels in WCF: transport channels and protocol channels. In this work we only care about transport channels. Transport channels read and write messages from the network. Examples of transports are named pipes, MSMQ, TCP/UDP or HTTP, all of which are involved in the scope of this work.

\section{Assembly Calling Convention}
Before we jumping into a specific communication channel, it is important to know some basic assembly calling convention.
Calling Convention is different for operating system and the programming language. Since we are looking into the messaging methods being used in windows communication framework, and since our case study is running on a Microsoft* x64 system, we only list the Microsoft* x64 calling convention for interfacing with C/C++ style functions:\par
\begin{enumerate}  
\item RCX, RDX, R8, R9 are used for integer and pointer arguments in that order left to right.
\item XMM0, 1, 2, and 3 are used for floating point arguments.
\item Additional arguments are pushed on the stack left to right. \ldots 
\item Parameters less than 64 bits long are not zero extended; the high bits contain garbage.
\item Integer return values (similar to x86) are returned in RAX if 64 bits or less.
\item Floating point return values are returned in XMM0.
\item Larger return values (structs) have space allocated on the stack by the caller, and RCX then contains a pointer to the return space when the callee is called. Register usage for integer parameters is then pushed one to the right. RAX returns this address to the caller.
\end{enumerate}


