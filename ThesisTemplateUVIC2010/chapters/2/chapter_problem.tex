\startchapter{Methodology}
\label{chapter:problem}

\newlength{\savedunitlength}
\setlength{\unitlength}{2em}
\section{Define the Problem}
A dual-trace consist of two execution traces that are generated from two interacting applications. The main difference between single trace analysis and Dual-trace analysis is the later one has to analysis the communication events of the applications in the traces. A communication event in the dual-trace is defined as a successfully send and received message. There are four essential elements in this event: send function call, receive function call, the sent message in the sender's memory and the received message in the receiver's memory. It takes a experience engineer minutes or even hours to locate one event. It become a huge task for them to find out all the events in the dual-trace. To assist them , the major goal of this work is building a tool to help reverse engineers to locate the communication events in the assembly traces from both sides of the dual-trace and present them. \par


\section{Define the Scope}
There are many types of communication between applications. Only Named pipe, MQMS, HTTP, TCP/UDP socket are targeted in this work since they are the most widely used ones in windows server/client service and are the ones used in the popular Window Communication Foundation. The framework we built is extendable to other communication types.

\section{Obtain Background Knowledge}
To locate the communication event of both side of the traces, we need to investigate the communication methods to figure out how they looks like in the assembly level traces. We need to know how the functions for channel setup work as well as the functions for messages sending/receiving. The system functions we are looking for is in C++ level. We have to know the C++ function names, related parameters, return value and so on.  In addition, to understanding what they looks like in the assembly level trace, we have to know the calling conventions in assembly, such registers/memory for parameters or return value.

\section{Model the Channels}
By understanding all the related function APIs, we modeled the communication channels. The model of each type of communication channel covers all the successful communication scenarios.
\section{Build the Prototype}
We build our prototype tool based on the developed models. The user should refer to the channel models to define the concerned communication type through the user interface we provide in the prototype tool. Defined communication type is later on used for locating the communication events in the dual-trace. However, not all scenarios of all models can be covered by our tools. For some scenarios, it is impossible to exactly locate all the communication event by program. The user has to have extra information to assist their analysis.

\section{Verify the Model and the Prototype Tool}


\setlength{\unitlength}{\savedunitlength}
