\startchapter{Background}
\label{chapter:Bac}
This section introduces several background knowledge or information that related to this work. First I describe what is software security and how important it is as well as our existing approach to assist detection of software vulnerabilities by assembly level trace analysis. Second, I discuss how software interaction affect the behavior of the software and the common communications among programs. Third, I introduce some tools for assembly level program debugging and analysis. One of those is Atlantis, the existing assembly level execution trace analysis environment, on which the implementation of this work based.

\section{Software Security and Vulnerability Prevention}
The internet grows incredibly fast in the past few year. More and more computers are connected to it in order to get service or provide service. The internet as a powerful platform for people to share resource, meanwhile, introduces the risk to computers in the way that it enable the exploit of the vulnerabilities of the software running on it. Accordingly, the emphasize placed on computer security particularly in the field of software vulnerabilities detection increases dramatically. It's important for software developers to build secure applications. Unfortunetely, this is usually very expensive and time consuming and somehow impossible. On the other hand, finding issues in the built applications is more important and practical. Howerver this is a complex process and require deep technical understanding in the perspetive of reverse engineering.\cite{dowd_art_2006}.


\section{Software Security and Vulnerability Detection}
A common approach to detect existing vulnerabilities is fuzzing testing, which record the execution trace while supplying the program with input data up to the crash and perform the analysis of the trace to find the root cause of the crash and decide if that is a vulnerability\cite{cleary_reconstructing_2013}. Execution trace can be captured in different levels, for example object level and function level. But my research only focus on those that captured in instruction and memory reference level. There are two main reasons for analysis system-level traces. First, it is for analysis of the software provided by vendor whose source code are not available. The second one is that low level trace are more accurately reflect the instructions that are executed by multicore hardware\cite{wang_predicting_2011}. 

\section{Program Communications}
Applications nowaday do not alway work isolately,  many software  appear as  reticula collaborating systems connecting different modules in the network\cite{PhysRevE.68.046116} which make the discovery of vulnerabilities even harder. The communication and interaction between modules affect the behavior of the software. Without regarding to the synergy information , analysis of the isolated execution trace on a single computer is usually futile. There are several methods for communication between programs. These methods can be categorized based on different perspective. One of these categorization is Internet versus Inter-process while the other one is reliable versus unreliable. In this work, communication methods belong to all these four categories has been covered. However, I only discuss the message based communication methods while leave the control based communication, like remote function call for the future.

\section{Program Execution Tracing in Assembly Level}
There are many tools that can trace a running program in assembly instruction level.  IDA pro \cite{eagle_ida_2008} is a widely used tool in reverse engineering which can capture and analysis system level execution trace. Giving open plugin APIs, IDA pro allows plugin such as Codemap \cite{_c0demap/codemap:_????} to provide more sufficient features for "run-trace" visualization. PIN\cite{_pin_????} as a tool for instrumentation of programs, provides a rich API which allows users to implement their own tool for instruction trace and memory reference trace. Other tools like Dynamic \cite{brueningqz} and OllyDbg\cite{yuschuk2007ollydbg} also provide the debugging and tracing functionality in assembly level. 

\section{Atlantis}
Atlantis is a trace analysis environment develop in Chisel. It can support analysis for multi-gigabyte assembly traces. There are several features distinct it from all other existing tools and make it particularly successful in large scale trace analysis. These features are 1) reconstruction and navigation the memory state of a program at any point in a trace; b) reconstruction and navigation of system functions and processes; and c) a powerful search facility to query and navigate traces. The work of this thesis is not a extension of Atlantis. But it take advantages of Atlantis by reusing it existing functionality to assist the dual\_trace analysis.




