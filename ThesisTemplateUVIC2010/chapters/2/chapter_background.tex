\startchapter{Background}
\label{chapter:Bac}
In this chapter, I summarize the background related to this work. First I generally describe what is a software vulnerability. Second, I discuss the categorization of communications among programs. Third, I introduce some tools for assembly level program debugging and analysis. Finally I introduce Atlantis, the existing assembly level execution trace analysis environment, on which the prototype of this work is based.

\section{Software Vulnerability}
Software vulnerability detection is one of the use cases of communication analysis with assembly level execution traces. Vulnerabilities, from the point of view of software security, are specific flaws or oversights in a program that can be exploited by attackers to do something malicious, such as modify sensitive information, disrupt or destroy a system, or take control of a computer system or program\cite{dowd_art_2006}. They are considered to be a subset of bugs. Input and data flow, interface and exceptional condition handling are where vulnerabilities most likely to surface in software. Memory corruption is one of the most common vulnerabilities. The awareness of these would make the security auditing and vulnerabilities detection have more clear focus. 

\section{Program Communications Categories}
Programs can communicate with each other via diverse mechanisms. The communication that happens among processes is known as inter-process communication. This refers to the mechanisms an operating system provides a process to share data with each other. It includes methods such as signal, socket, message queue, shared memory and so on \cite{garrido2000inter}. These communications can happen over a network or inside a device. Based on their reliability, the communication methods can be divided into two categories: reliable communication and unreliable communication. In this work, both communication methods are covered. However, I only discuss message based communication methods while leaving other communication methods such as remote procedural call for feature works.

\section{Program Execution Tracing at the Assembly Level}
The communication analysis discussed throughout this thesis is based on assembly traces. Thus, capturing execution traces became a prerequisite of this work. DRDC has its own home-made tracer, and generated the traces used in the experiments of this research. However, the model and algorithms developed in this research are not limited to this specific home-made tracer. Any tracer that can capture sufficient information according to the model can serve this purpose.

There are many tools that can trace a running program at the assembly instruction level.  IDA\_pro \cite{eagle_ida_2008} is a widely used tool in reverse engineering which can capture and analyze system level execution traces. Through open plugin APIs, IDA pro allows plugin such as Codemap \cite{_c0demap/codemap:_????} to provide more sufficient features for ``run-trace" visualization. PIN \cite{_pin_????} is a tool for the instrumentation of programs, provides a rich API which allows users to implement their own tool for instruction trace and memory reference traces. Other tools like Dynamic \cite{brueningqz} and OllyDbg \cite{yuschuk2007ollydbg} also provide debugging and tracing functionality at the assembly level. 

\section{Atlantis}
Atlantis is a trace analysis environment developed in the Chisel lab at the University of Victoria \cite{huang2017atlantis}. It can support analysis for multi-gigabyte assembly traces. There are several features that distinguish it from all other existing tools and make it particularly successful in large scale trace analysis. These features are 1) reconstruction and navigation the memory state of a program at any point in a trace; b) reconstruction and navigation of system functions and processes; and c) a powerful search facility to query and navigate traces \cite{huang2017atlantis}. The work of this thesis is not an extension of Atlantis. But it takes advantage of Atlantis by reusing its existing features to assist the dual\_trace analysis. The reason that I choose Atlantis for communication analysis is not because it was develop by the research I work in, but the features that it already has make the implementation of the communication analysis prototype much easier than developing a new tool or use some other existing tool such as IDA\_pro.




